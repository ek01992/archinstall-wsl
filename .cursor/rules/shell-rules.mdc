---
alwaysApply: false
---

# Shell Style Guide (Google-derived)

## Background

### Which Shell to Use

- Use bash only for executables: shebang must be #!/bin/bash with minimal flags.
- Configure options via set inside the script so bash script_name works.
- No need for POSIX sh compatibility unless the target environment requires it.

### When to Use Shell

- Good for short utilities/wrappers that orchestrate other tools.
- Avoid for performance-critical or complex logic (>100 lines or nontrivial control flow) — use a structured language instead.
- Optimize for maintainability by others.

## Shell Files and Interpreter Invocation

### File Extensions

- Executables: prefer .sh when built/renamed by rules; prefer no extension if installed directly in PATH. Either is acceptable otherwise.
- Libraries: must end with .sh and be non-executable.

### SUID/SGID

- Forbidden for shell scripts. Use sudo for elevated access.

## Environment

### STDOUT vs STDERR

- Send errors to STDERR. Provide an err helper.

#### Example: err()

```sh
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

if ! do_something; then
  err "Unable to do_something"
  exit 1
fi
```

## Comments

### File Header

- Start with a brief description (copyright/author optional).

#### Example: cleanup()

```sh
# !/bin/bash

# Perform hot backups of Oracle databases
```

### Function Comments

- Required for nontrivial functions and all library functions. Document:
  - Description
  - Globals used/modified
  - Arguments
  - Outputs (STDOUT/STDERR)
  - Returns (non-default)

#### Example

```sh
#######################################

# Cleanup files from the backup directory

# Globals: BACKUP_DIR, ORACLE_SID

# Args: None

# Returns: None

#######################################
cleanup() {
  :
}
```

#### Example: get_dir()

```sh
#######################################

# Get configuration directory

# Globals: SOMEDIR

# Outputs: Writes location to STDOUT

#######################################
get_dir() {
  echo "${SOMEDIR}"
}
```

#### Example: del_thing()

```sh
#######################################

# Delete a file

# Args: $1 - path to delete

# Returns: 0 if deleted, non-zero on error

#######################################
del_thing() {
  rm -- "$1"
}
```

### Implementation Comments

- Comment tricky or non-obvious logic; avoid redundant commentary.

### TODO Comments

- Use TODO(NAME): message. Include owner/identifier for context.
- Example: # TODO(mrmonkey): Handle edge cases (bug ####)

## Formatting

### Indentation

- 2 spaces; no tabs. Separate logical blocks with blank lines.
- Only exception: use tabs inside <<- heredocs.

### Line Length and Long Strings

- Max 80 chars. Use heredocs or embedded newlines for long literals.
- Place long unbreakable tokens (e.g., URLs/paths) on their own line or assign to a variable.

### Pipelines

- Break long pipelines across lines aligned for readability.
- Prefer checking PIPESTATUS if needed (see Calling Commands).

### Control Flow

- Use [[ ... ]] for tests; (( ... )) for arithmetic.
- Use case for multi-branch string patterns.

### Case Statement

- Quote patterns only when needed; include a default *) branch.

### Variable Expansion

- Prefer ${var} form; elide braces only when unambiguous.
- Use parameter expansion instead of external tools when practical.

### Quoting

- Quote variables by default: "${var}".
- Quote command substitutions: "$(cmd)".
- Prefer single quotes for literal strings without interpolation.
- Don’t quote integers; do quote shell metacharacters.
- Use "$@" to forward args; avoid $* (except for the “join into one arg” case).

## Features and Bugs

### ShellCheck

- Run ShellCheck on all scripts.

### Command Substitution

- Use $(cmd), not backticks. Nests cleanly.
- Example: var="$(outer "$(inner)")"

### Test: [ … ], [[ … ]], test

- Prefer [[ … ]]: no globbing/splitting; supports patterns/regex.
- Example:

```sh
if [[ "filename" =~ ^[[:alnum:]]+name ]]; then
  echo "Match"
fi
if [[ "filename" == f* ]]; then
  echo "Match"
fi
```

### Testing Strings

- Prefer -z and -n for emptiness tests.
- Use [[ "${v}" == "val" ]] for equality. Avoid filler chars (e.g., "${v}X").
- For numeric comparisons use (( ... )) or -lt/-gt; < and > in [[ ]] are lexical.

### Wildcard Expansion of Filenames

- Use explicit paths to avoid options-from-filenames:
  rm ./*# safer than rm*

### Eval

- Avoid eval due to quoting/injection/observability issues.

### Arrays

- Use arrays to manage lists/arguments safely; expand with "${arr[@]}".
- Avoid building multi-arg strings; avoid unquoted command substitution into arrays.

#### Example: flags

```sh
declare -a flags
flags=(--foo --bar="baz")
flags+=(--greeting="Hello ${name}")
mybinary "${flags[@]}"
```

### Pipes to while

- Piping to while runs the loop in a subshell; variables won’t persist.
- Prefer:
  - Process substitution: while read -r line; do ...; done < <(cmd)
  - Or readarray (bash 4+):
    readarray -t lines < <(cmd)
    for line in "${lines[@]}"; do ...; done
- Avoid for var in $(cmd) unless whitespace-splitting is guaranteed safe.

### Arithmetic

- Use (( ... )) and $(( ... )); avoid let, $[ ... ], expr.
- Beware set -e with standalone (( ... )) when expression can be 0.
- Within $(( ... )), variable braces are optional.

#### Example: my_func()

```sh
echo "$(( 2 + 2 ))"
if (( a < b )); then :; fi
(( i = 10 * j + 400 ))
local -i hundred="$(( 10 * 10 ))"
(( i += 3, i -= 5 ))
```

### Aliases

- Avoid aliases in scripts; use functions instead.

## Naming Conventions

### Function Names

- lower_snake_case; package namespaces with :: if desired (be mindful of completion).
- Consistently use or omit the function keyword; parentheses required; brace on same line.

#### Example: lower_snake_case

```sh
my_func() { :; }
mypkg::do_work() { :; }
```

### Variable Names

- lower_snake_case; loop variables named consistently with what they iterate.

#### Example: ZIP_VERSION

```sh
for zone in "${zones[@]}"; do
  process_zone "${zone}"
done
```

### Constants, Environment Variables, readonly

- CAPITAL_SNAKE for constants and exported vars; declare at top.
- Prefer readonly and export over declare variants; setting then marking readonly is OK.

#### Example: ZIP_VERSION - readonly

```sh
readonly PATH_TO_FILES='/some/path'
export PATH_TO_FILES

ZIP_VERSION="$(dpkg --status zip | sed -n 's/^Version: //p')"
if [[ -z "${ZIP_VERSION}" ]]; then
  ZIP_VERSION="$(pacman -Q --info zip | sed -n 's/^Version *: //p')"
fi
[[ -z "${ZIP_VERSION}" ]] && handle_error_and_quit
readonly ZIP_VERSION
```

### Source Filenames

- lowercase_with_optional_underscores (no hyphens).

### Use Local Variables

- Use local for function-scoped vars.
- When assigning from command substitution, split declaration and assignment to preserve exit status.

#### Good: my_func2()

```sh
my_func2() {
  local name="$1"
  local my_var
  my_var="$(my_func)"
  (( $? == 0 )) || return
}
```

#### Bad: my_func2()

```sh
my_func2() {
  local my_var="$(my_func)"   # $? now refers to local, not my_func
  (( $? == 0 )) || return
}
```

### Function Location

- Place includes, set options, and constants first; then all functions; then main.

### main

- For multi-function scripts, define a main() at bottom and call it on the last line.
- Short linear scripts may omit main.

### Calling Commands

### Checking Return Values

- Check return codes and emit informative errors.

#### Example: mv_files()

```sh
if ! mv "${file_list[@]}" "${dest_dir}/"; then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi
```

### Pipelined commands

```sh
tar -cf - ./* | ( cd "${dir}" && tar -xf - )
if (( PIPESTATUS[0] != 0 || PIPESTATUS[1] != 0 )); then
  echo "Unable to tar files to ${dir}" >&2
fi
```

### If you need per-stage handling, snapshot immediately

```sh
tar -cf - ./* | ( cd "${DIR}" && tar -xf - )
local rc=( "${PIPESTATUS[@]}" )
(( rc[0] != 0 )) && handle_tar_create_error
(( rc[1] != 0 )) && handle_tar_extract_error
```

### Builtin Commands vs. External Commands

- Prefer bash builtins (parameter expansion, regex matching, arithmetic) over external tools for speed/robustness/portability.

#### Example: addition()

```sh
addition="$(( X + Y ))"
substitution="${string/#foo/bar}"
if [[ "${string}" =~ foo:(\d+) ]]; then
  extraction="${BASH_REMATCH[1]}"
fi
```

### Arguments Forwarding Tips

- "$@" preserves argument boundaries; $* and $@ (unquoted) split on IFS.
- "$*" joins args into a single word (usually space-delimited).
- Use "$@" almost always when forwarding.

### When in Doubt: Be Consistent

- Consistency simplifies review, tooling, and maintenance. Prefer the prevailing style in existing files. Adopt newer, clearer patterns where appropriate.
